### 差分配列と累積和の仕組みについて

#### まず、変化点だけを記録するという発想が必要。

通常、区間 l,r に対して　その区間内のすべての位置に直接記録すると、
1 つの区間につき最大で N 回（文字列の長さ）の操作が必要になる。

しかし、差分配列では「変化が起こる点だけ」を記録する。つまり、

- 区間の開始地点で「ここから操作回数が 1 増える」という変化を +1 で記録
- 区間の終了地点の次で「ここから操作回数が 1 減る」という変化を-1 で記録

#### 累積和が「実際の値」を復元する理由

累積和は「その位置までの変化の合計」を計算する。

例えば、ある位置での累積和が「3」だとすると、それは「スタート地点からその位置まで、操作回数を増やす変化が操作回数を減らす変化より 3 回大衡発生した」ことを意味する。

このような状況があったとする。

```typescript
cummulative = [1, 1, 0, -1, -1, 0]
↑ ↑ ↑ ↑ ↑ ↑
0 1 2 3 4 5 (インデックス)
```

下記のコードが何を意味するか？

```ts
// 累積和で実際の操作回数を復元
for (let i = 0; i < N; i++) {
  cummulative[i + 1] += cummulative[i]
}
```

一言で言うと、「左隣の値を自分に足していく」処理である。
これにより、各位置では「自分より左にあるすべての変化量の合計」が計算される。

（だから、終了位置で-1 をすることが必要になる）

- cummulative[0] = 自分だけ = 1
- cummulative[1] = 自分 + 左隣 = 1 + 1 =2
- cummulative[2] = 自分 + (左隣 + そのまた左隣) = 0 + 2 =2
- cummulative[3] = 自分 + (左隣までの合計) = -1 + 2 =1

→ 　各位置において、和が偶数であれば S の値をとればよく、奇数であれば T の値をとればよい。
