## この問題のアルゴリズムとは

まず、数列 A,数列 B を昇順にソートする。
順番に、数列 A,数列 B を前から順番に足していく。
足した結果、 m より小さい値なら、それを (a + b) mod m のその組の答えとして加算する。
足した結果、m より小さい値なら、m の足す位置を前ではなく、後ろ、つまり一番大きな値で足す仕組みに切り替える。
a は使い切るために、a を足す位置は変更しない。

そのとき、足した a と b のペアで (a +b) mod m を計算して答えとする。　このとき、 a + b の値は m 　より大きい値になっている。

### ペアの考え方のポイント

a +　 b の結果として、　 m より小さいときは、できる限り小さい値同士でペアを作るのが重要。

(a+ b) mod m の　答えが取りうる値の可能性としては、線形のグラフが 右肩上がりに　 m まで上昇し、その後、m になるタイミングで 0 になり、また 2m の値まで線形に近づく、ということになる。

最悪なのは、 m より 1 小さい、といった状況。最高なのは a + b が m と一致すること。

ここまでは私のメモであり、ここからは claude による回答をメモしていく。

---

### 問題の本質

この問題は「A 配列と B 配列から 1 つずつ要素を選んでペアを作り、各ペアの和を mod m した結果の総和を最小化する」問題。

#### なぜこのアルゴリズムが最適解になるのか

1. 基本戦略：　小さい値同士、大きい値同士をペアにする

modular arithmetic において、 (a + b) mod m の結果を最小化にするは：

- a + b < m の場合： mod 操作は発生せず、結果は a+b そのまま
- a + b ≥ m の場合：結果は a + b - m になる

この性質から、小さい値同士はペアにして mod 操作を避け、大きい値同士をペアにして mod 操作による「損失」を最小化する戦略が最適になる。

2. アルゴリズムの仕組み

```typescript
//両配列を昇順ソート→小さい値から処理可能
aSequence.sort((a, b) => a - b)
bSequence.sort((a, b) => a - b)

let jIndex = n - 1 // B配列の最大値のインデックス

for (let i = 0; i < n; i++) {
  totalSum += aSequence[i] + bSequence[i] //最初は小さい値同士

  if (m <= aSequence[i] + bSequence[jIndex]) {
    totalSum -= m //mod操作実行
    jIndex-- // 次はより小さいB値を使う
  }
}
```

3. なぜこのアルゴリズムが最適なのか
   このアルゴリズムが最適な理由は交換論証にあります：
   - 小さい A[i]と大きい B[j]をペアにした場合
   - 大きい A[k]と小さい B[l]をペアにした場合
     この 2 つを交換して、「小さい値同士」「大きい値同士」にペアを変更すると、総和は必ず改善されるか同じになります。

具体的には、 A[i] ≤ A[k], B [l] ≤ B[j]　のとき：

- 交換前:`(A[i] + B[j]) mod m + (A[k] + B[l]) mod m`
- 交換後:`(A[i] + B[l]) mod m + (A[k] + B[j]) mod m`
