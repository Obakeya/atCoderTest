この問題を DP として解ける理由
「上から

---

1 行の白/黒パターンは 2^W 通りある。

例えば、下記のとき、

```
□ □ □ ← この 1 行で、各マスは白(.)か黒(#)
```

それぞれのマスごとに、　.　か # が決定できるから、
2 ^ 3 　通り。したがって、 ある行の白・黒のパターンは　 2^W 通りある。

```ts
const k = 1 << w // 2^w 通りの状態
```

とは、2 の累乗を左シフトで計算する方法。

下記でやっていること

```ts
// 状態遷移可能性を事前計算
const allow: boolean[][] = Array(k)
  .fill(null)
  .map(() => Array(k).fill(true))
```

「前の行と現在の行の組み合わせで、2\*2 の黒い部分ができるかどうか」の判定表を準備している。

allow[前の行の状態][現在の行の状態] = 繊維可能か？

- true:この組み合わせでは 2\*2 の黒ができない → 遷移 OK
- false:この組み合わせで 2\*2 の黒ができる → 遷移 NG

下記でやっていること

```ts
// 隣接する2ビットが両方1なら遷移不可能
if (((i >> ii) & 3) === 3 && ((j >> ii) & 3) === 3) {
  allow[i][j] = false
  break
}
```

ある 2\*2 マスの状況を確認して、すべて黒色の場合は、選択ができないため、スキップしていいものとして、false として設定する。

> > は右ビットシフトのため、指定の位置を右にずらすことで、指定の位置の値を確認している

allow[i][j]は、とりうる状態パターン行の 2 つの組において、黒マス 2\*2 となるところができないかどうかをチェックしている。実際の行数は関係ないことに注意。

下記でやっていること

```ts
if ((j | state) === state) {
```

現実的に遷移な可能な状態かをチェックしている。遷移において、行えるのは黒 → 白であり、　白 → 黒の遷移は行うことができない。　そのため、　比較している j と state の状態において、遷移が可能な組なのかどうかを確認している。

---

なんで dp と dp2 があるのか
