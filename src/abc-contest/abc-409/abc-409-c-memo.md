## 問題の本質

円周上の N 個の点から 3 つを選んで**正三角形**を作る問題です。正三角形になるには、3 点が円周上で**等間隔**に配置されている必要があります。

## 解法の考え方

### 1. 各点の座標を計算

点 1 を基準座標 0 として、各点の円周上での位置を計算します。

### 2. 正三角形の条件

3 点が正三角形を形成するには、円周を 3 等分した位置に配置されている必要があります：

- 座標 `k`, `k + L/3`, `k + 2L/3` に点がある（k は任意の開始位置）
  - したがって、円周の長さは 3 の倍数である必要があります
  - 3 の倍数で無い場合、3 つの点を等間隔に配置することができません

### 3. 組み合わせの計算

各座標での点の個数をカウントし、3 つの座標それぞれにある点数の積を求めます。

## TypeScript 実装

全体の計算量を O(N+L)とする。
N...点の

```typescript
export function solve(input: string) {
  const lines = input.trim().split('\n')
  const [N, L, ...d] = lines[0].split(' ').map(Number)

  // Lが3で割り切れない場合、正三角形は作れない
  if (L % 3 !== 0) {
    console.log(0)
    return
  }

  // 各点の座標を計算（累積和）
  const coordinates = new Array(N)
  coordinates[0] = 0 // 点1の座標は0

  for (let i = 1; i < N; i++) {
    coordinates[i] = (coordinates[i - 1] + d[i - 1]) % L
  }

  // 各座標での点の個数をカウント
  const count = new Array(L).fill(0)
  for (let i = 0; i < N; i++) {
    count[coordinates[i]]++
  }

  // 正三角形を形成する組み合わせ数を計算
  let answer = 0
  const step = L / 3 // 正三角形の各頂点間の距離

  for (let k = 0; k < step; k++) {
    // 座標k, k+step, k+2*stepにある点の組み合わせ
    const pos1 = k
    const pos2 = k + step
    const pos3 = k + 2 * step

    answer += count[pos1] * count[pos2] * count[pos3]
  }

  console.log(answer)
}
```

####　座標計算について
**coordinates**は「**座標**」という意味で、各点が円周上の**どの位置にあるか**を表す数値です。毎回円周の長さで割り、割った余りで座標いちを求めるのがポイント。また、その位置を把握するために、累積和の考え方も採用する。

##### 具体例で理解しましょう

##### 入力例：`5 6 4 3 1 2`

- N=5（5 個の点）, L=6（円周 6）
- d = [4, 3, 1, 2]（各点間の距離）

##### 点の配置を順番に計算

```typescript
// 点1: 基準位置（座標0）
coordinates[0] = 0

// 点2: 点1から時計回りにd[0]=4進む
coordinates[1] = (0 + 4) % 6 = 4

// 点3: 点2から時計回りにd[1]=3進む
coordinates[2] = (4 + 3) % 6 = 1

// 点4: 点3から時計回りにd[2]=1進む
coordinates[3] = (1 + 1) % 6 = 2

// 点5: 点4から時計回りにd[3]=2進む
coordinates[4] = (2 + 2) % 6 = 4
```

## 視覚的な理解

```
    0
    ↑点1
5 ←   → 1
    ↑点3
4 ←   → 2
  ↑点2,5  ↑点4
    3
```

## なぜ累積和なのか

各点の位置は「**スタート地点からの総移動距離**」で決まります：

```typescript
// 点1からの総移動距離
点1: 0
点2: d[0] = 4
点3: d[0] + d[1] = 4 + 3 = 7 → 7%6 = 1
点4: d[0] + d[1] + d[2] = 4 + 3 + 1 = 8 → 8%6 = 2
点5: d[0] + d[1] + d[2] + d[3] = 4 + 3 + 1 + 2 = 10 → 10%6 = 4
```

## コードの役割

```typescript
coordinates[i] = (coordinates[i - 1] + d[i - 1]) % L
//               ↑前の点の座標    ↑今回の移動距離   ↑円周で割った余り
```

**つまり**：

- `coordinates[i]` = 点 i が円周上のどこにいるか
- `% L` = 円周を超えたら一周回る（円の性質）
- 累積和 = スタートからの総移動距離を効率的に計算

**結果**: `coordinates = [0, 4, 1, 2, 4]`
これで各点の円周上での位置が確定し、正三角形の判定ができるようになります。

## 具体例での動作確認

**入力例 1**: `5 6 4 3 1 2`

```typescript
N = 5, L = 6, d = [4, 3, 1, 2]

// 1. 座標計算
coordinates[0] = 0                    // 点1
coordinates[1] = (0 + 4) % 6 = 4      // 点2
coordinates[2] = (4 + 3) % 6 = 1      // 点3
coordinates[3] = (1 + 1) % 6 = 2      // 点4
coordinates[4] = (2 + 2) % 6 = 4      // 点5

// 2. カウント配列
count[0] = 1, count[1] = 1, count[2] = 1, count[4] = 2

// 3. 正三角形の組み合わせ（step = 6/3 = 2）
k = 0: pos(0,2,4) → count[0] * count[2] * count[4] = 1 * 1 * 2 = 2
k = 1: pos(1,3,5) → count[1] * count[3] * count[5] = 1 * 0 * 0 = 0

// 答え: 2
```

## ポイント

**正三角形の条件**: 円周上で等間隔（L/3）に配置された 3 点
**効率的な計算**: 各座標での点数をカウントしてから組み合わせ数を計算
**エッジケース**: L が 3 で割り切れない場合は必ず 0

この解法により、O(N + L)の時間計算量で解くことができます。
