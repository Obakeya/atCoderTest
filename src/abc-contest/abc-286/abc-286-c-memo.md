「文字列を連結することで、文字列のローテーションの結果をシンプルに表現することができる」

具体例で説明します。文字列 `"abcde"` (N=5) を使って見ていきましょう。

## 文字列の 2 倍連結について

元の文字列が `"abcde"` だとします。これを 2 倍にすると `"abcdeabcde"` になります。

ここで、左に 2 文字回転させる操作を考えてみます。通常の考え方だと「先頭 2 文字を取り除いて末尾につける」という処理になり、`"abcde"` → `"cdeab"` となります。

しかし 2 倍にした文字列を使うと、この回転操作を「位置 2 から 5 文字取り出す」という単純な切り出しで表現できます。実際に見てみると:

```
abcdeabcde
  ^^^^^
  位置2から5文字 → "cdeab"
```

同様に、0 回転なら位置 0 から 5 文字で `"abcde"`、1 回転なら位置 1 から 5 文字で `"bcdea"`、3 回転なら位置 3 から 5 文字で `"deabc"` となります。この方法を使うことで、文字を末尾に移動させるという複雑な処理を、単に「開始位置をずらして取り出す」という簡単な操作に置き換えられるわけです。

---

「実際の回文の値の取り方について。i の開始位置でローテーション回数を表現し、j で 1 文字ずつ、ずらしてチェックすることを表現する」

### leftPos = i + j の意味

`j` は回転後の文字列の左端から数えた位置です。回転開始位置が `i` なので、2 倍文字列上での実際の位置は `i + j` になります。

```
j=0のとき（回転後文字列の1文字目）:
2倍の文字列:   a b c d e a b c d e
                    ^
              位置 i+j = 2+0 = 2 → 'c'

j=1のとき（回転後文字列の2文字目）:
2倍の文字列:   a b c d e a b c d e
                      ^
              位置 i+j = 2+1 = 3 → 'd'
```

### rightPos = i + N - 1 - j の意味

回文判定では、左端から `j` 番目と右端から `j` 番目を比較します。右端から `j` 番目というのは、左端から数えると `N - 1 - j` 番目です（0 始まりなので N-1 が最後の位置）。

回転開始位置が `i` なので、2 倍文字列上での実際の位置は `i + (N - 1 - j)` となります。

```
j=0のとき（回転後文字列の最後の文字）:
回転後文字列: c d e a b
              ^       ^
              j=0    N-1-j = 5-1-0 = 4

2倍の文字列:   a b c d e a b c d e
                    ^       ^
              位置2        位置 i+N-1-j = 2+4 = 6 → 'b'

j=1のとき:
回転後文字列: c d e a b
                ^   ^
                j=1  N-1-j = 5-1-1 = 3

2倍の文字列:   a b c d e a b c d e
                      ^   ^
              位置3    位置 i+N-1-j = 2+3 = 5 → 'a'
```
