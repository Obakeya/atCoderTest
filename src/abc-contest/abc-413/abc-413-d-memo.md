413 d 問題では、bigInt で数値を扱うために、単純な Math.abs()を利用することができず、
bigInt 用の関数を用意しても d 内を解くことになる。
用意した関数およびコードの振る舞いについて、記述する。

```typescript
// BigInt 用の並び替え関数を用意する
const abs = (x: bigint): bigint => (x < 0n ? -x : x)
// 絶対値の大きいものから順にソートしている

/* ---- |r| < 1 判定 ---- */
A.sort((a, b) => {
  //bigintを扱うため、絶対値は専用関数を用意する
  const da = abs(a),
    db = abs(b)
  if (da > db) return -1
  if (da < db) return 1
  // 絶対値が同じなら大きい方を先に（なくても AC）
  return a > b ? -1 : a < b ? 1 : 0
})
```

`Array.prototype.sort()`に渡す比較関数は、2 つの要素`a`と`b`の並び順を決めるために"符号つきの数値"を返す仕組みになっています。

返す値が負数になるときは、a を先、 b を後に置きます。
返す値が正数の場合、 b を先、 a を後に置く、という振る舞いになります。
覚え方としては、(a,b)としたときに、返す値が正の値であれば、a,b 順になるし、 返す値が負の数であれば、b,a 順になります。

そのため、絶対値として比較後、 a < b の時に、-1 を返すことで、b を降順にもってくることができます。

```typescript
A.sort((a, b) => a - b) //昇順に並べ替えるコード。 a > bのとき、正の値が変えることで、bの値が先に、aの値が後になる。 a < bのときは、負の値が変えることで、そのままの順になる。
A.sort((a, b) => b - a) //降順に並べ替えるコード
```

上記のコードで、昇順に並び変わるのと同じメカニズムです。　 b のほうが値が大きいならば、返す結果は-になるため、a を先におき、b を後に置く、ということになります。
a, b と書いて、マイナスが返ってきたら並び順をそのままにし、正の値が返ってきたら並び順を変える、というメカニズムになっていることに注意。

---

下記の if 文内の判定について分析する

```typescript
let ok = true
for (let i = 0; i + 2 < N; ++i) {
  if (A[i] * A[i + 2] !== A[i + 1] * A[i + 1]) {
    ok = false
    break
  }
}
out.push(ok ? 'Yes' : 'No')
```

16,8,4,2 と数字があった時に、

16 * 4 =64 であり、　 8 *8 = 64 となる。したがって、等比数列であることが分かる。

なぜ掛け算比較なのか

- 整数どうしの割り算だと 0 除算や丸め誤差の心配がある
- 両辺を積にしておけば"=?"で安全に比較できる
- ただし、|Ai|≦ 10^9 で積は最大 10^18 のため、number ではなく BigInt を使う。
