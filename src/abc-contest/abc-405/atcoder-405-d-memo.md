### 解くための考え方

迷路上のすべての非常口から、同時に最短距離を広げていく多重スタート BFS を行えば、各空きマスに「出口へ向かう最短経路の次の一手」を逆向き矢印で書き込める。

- BFS は波紋のように等距離そうを作るため、先に訪れたマスは必ず最短距離で確定する
- あるマス v をキューから取り出し、隣接マス u に初めて到達した瞬間に、u へ逆方向の ⇔（parent→child ではなく child から parent を指す）を刻むと、その矢印をたどる回数がそのまま距離にになる。

### 実装の勘所

- グリッドサイズ H\*W に対して配列を二つ持つだけで済む
  - `dist`:未訪問は -1 、訪問済みは距離
  - `grid`:入力を写しつつ、空きマスは探索中に矢印へ置換
- `queue`を 2 本の配列(x[],u[])で実装すれば Node.js でも定数倍が軽い
- 移動は 4 近傍で固定なので、`dx,dy` テーブルと、矢印変換テーブル`['v','^','>','<']`を用意。
- BFS 開始点はすべての'E'。同距離スタートにするため、最初にキューへすべて突っ込む。
- 最後に`gird`をそのまま join して出力

### 計算量

時間 : O(H·W) ― 各マスを一度だけキューに入れる。

メモリ : O(H·W) ― 距離配列とグリッドそのもの。
