問題文の数式の理解が難しかったため、分解して理解する。

### 文章を日本語に“ばらして”読むとこうなります

---

#### 1 行目

> **$A_{i-1} < A_i > A_{i+1}$ を満たす $2 \le i < |A|$ なる整数 $i$ はちょうど 1 個である**

- **$A_{i-1} < A_i > A_{i+1}$**

  - 真ん中の Ai が両隣より大きいーーつまり山（ピーク）になっていることを意味します。
    - |A|とは配列の A 要素数、つまり A に含まれている値の個数を表します。

- **$2 \le i < |A|$**

  - 比較の都合で、先頭(i=1)と末尾(i=|A|)は除外する

- **「ちょうど 1 個」**

  - そんなピークが配列 A の中に一度だけ出てくる、という宣言です。

要するに「内側に山が 1 つだけある」という条件。

---

#### 2 行目

> **$A_{i-1} > A_i < A_{i+1}$ を満たす $2 \le i < |A|$ なる整数 $i$ はちょうど 1 個である**

こちらは、山を谷に置き換えただけ。

- **$A_{i-1} > A_i < A_{i+1}$**

  - 真ん中の Ai が両隣より小さいーーつまり谷（ボトム）。

- **「ちょうど 1 個」**

  - 谷も **1 回だけ** 現れます。

---

### どう理解するか ― 手順をまとめると

1. **不等号が示す形を図にしてみる**

   - 「<」→ 上昇／「>」→ 下降で折れ線を描くと、
     1 行目は **上がって → 下がる**、2 行目は **下がって → 上がる** 点を表すと分かります。

2. **“ちょうど 1 個”に注目する**

   - 山が 1 つ・谷が 1 つ ⇒ 波形は **必ず「上がる-下がる-上がる」** か **「下がる-上がる-下がる」** の 3 区間で終わる。

3. **インデックス範囲を意識する**

   - 比較対象が両隣に必要なので、端の要素は山・谷の候補になりません。

---

このチルダ型の条件には、

- A の長さ|A|は 4 以上であるという条件も含まれています
- 山、谷が必要なため、最低でも 4 要素が必要になる。3 要素では、1 つの山、谷しか作れない。ここで、問題文の入力例および、回答例について、考えてみる。

- アルゴリズム概要
- 1.  隣接ペアの大小を +1 / –1 で符号化する（同値は 0）。
- 2.  符号列を run-length 圧縮して
- (+, a) , (-, b) , (+, c)
- という 3 連続ブロックが現れるたびに a × c を加算。
- これは「＋…−…＋」で始まり終わる＝チルダ型区間が a×c 本ある、という事実による。
- 3.  圧縮と走査は一周で済むので計算量は O(N)、メモリも O(N)。

```typescript


import \* as fs from 'fs';

// ---------- 入力 ----------
const dat = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);
if (dat.length === 0) process.exit(0);
const N = dat[0];
const A = dat.slice(1);

// ---------- 1. 隣接比較 → run-length ----------
const signRuns: number[] = []; // +1 or –1
const lenRuns: number[] = []; // run length

let curSign = 0; // 今見ている run の符号（+1 / –1）
let curLen = 0; // その長さ

for (let i = 0; i < N - 1; i++) {
let s = 0;
if (A[i] < A[i + 1]) s = 1;
else if (A[i] > A[i + 1]) s = -1;
// s === 0 なら A[i] == A[i+1] ── チルダ型は越えられない壁なので run を切る
if (s === 0) {
if (curLen > 0) {
signRuns.push(curSign);
lenRuns.push(curLen);
curLen = 0;
}
curSign = 0;
continue;
}
if (curLen === 0 || curSign === s) {
// 新しい run を始める or 同じ符号が継続
curSign = s;
curLen++;
} else {
// 符号が反転したので run を確定
signRuns.push(curSign);
lenRuns.push(curLen);
curSign = s;
curLen = 1;
}
}
if (curLen > 0) {
signRuns.push(curSign);
lenRuns.push(curLen);
}

// ---------- 2. (+,-,+) を数え上げ ----------
let ans = 0;
for (let i = 0; i + 2 < signRuns.length; i++) {
if (signRuns[i] === 1 && signRuns[i + 1] === -1 && signRuns[i + 2] === 1) {
ans += lenRuns[i] \* lenRuns[i + 2]; // 左右 run の掛け算が個数
}
}

console.log(ans.toString());
```

## ランレングス圧縮 (Run-Length Encoding, RLE) とは？

連続して並ぶ **同じ値の“かたまり”** を
`(値, 連続長)` のペアに置き換えてデータ量を減らす **可逆圧縮手法**。

---

### アルゴリズム（最小構成）

1. **入力列を左から走査**
2. 現在の値 `v` とその連続長 `cnt` を数え上げる
3. 途中で値が変わったら `(v, cnt)` を出力し，新しい値で繰り返す
4. 末尾まで行ったら最後の `(v, cnt)` も出力して終了

```text
例) AAAABBBCC → (A,4) (B,3) (C,2)
```

---

### 疑似コード（配列版）

```pseudo
result = []
i = 0
while i < n:
    v   = A[i]
    cnt = 0
    while i < n and A[i] == v:
        cnt += 1
        i   += 1
    result.append( (v, cnt) )
return result
```

- **復元**は `(値, 長さ)` をそのまま展開するだけ。

---

### 特徴・適用場面

| 長所                                          | 短所                               |
| --------------------------------------------- | ---------------------------------- |
| 実装が非常に簡単                              | 連続長が短いデータではかえって増量 |
| 計算量 **O(N)**、追加メモリ少                 | ランダムデータには不向き           |
| 列データの **区間集約** にも便利 (競プロなど) | 符号化後はランダムアクセスしにくい |

**よく使う例**: 白黒イメージ、FAX、連続ビット列、同値が多いログ列、
競技プログラミングで _符号列の反転回数_ や _連続区間_ を高速に扱うとき など。

---

### 計算量

- 圧縮・伸長とも **時間 O(N)**
- 圧縮後サイズは最悪 `2×(非ゼロ run 数)` 要素
