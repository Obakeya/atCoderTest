### 正解コードの解説

Set<number>[] は 「Set<number>の配列」 です。つまり、配列の各要素が Set になっている構造です。

```typescript
// 例：4 つの頂点を持つグラフの場合
const defaultEdges: Set<number>[] = [
  new Set([1, 2]), // 頂点 0 は頂点 1,2 と繋がっている
  new Set([0, 3]), // 頂点 1 は頂点 0,3 と繋がっている
  new Set([0]), // 頂点 2 は頂点 0 と繋がっている
  new Set([1]) // 頂点 3 は頂点 1 と繋がっている
]
```

上記のように、隣接するリストを表現可能

###　無向グラフ用の正規化処理について

```typescript
if (a > b) [a, b] = [b, a] //無向グラフを意識した正規化処理
defaultEdges[a].add(b)
```

上記のような構造がある。なぜ必要か。

無向グラフでは法王が無いため、同じ辺を 2 通りで表現できてしまう。

```typescript
//入力 3,1のとき

//正規化しないときは
defaultEdges[3].add(1) // 頂点3のSetに1を追加する

//でも後で頂点1から見ると...
defaultEdges[1].has(3) // false! (記録されていない)
```

そこで、一貫して、小さいほうの番号のリストに、隣接する番号を登録する方針で統一する

```typescript
if (a > b) [a, b] = [b, a] // 3 > 1 なので [a,b] = [1,3]
defaultEdges[a].add(b) //defaultEdges[1].add(3)
```

### Infiity の使いどころについて

どんな値よりも Infity は大きい値のため、初期値は無限大として設定しておき、
探索で見つけた実際の値で更新していく戦略をとるため。

```typescript
best = Math.min(Infitiy, 5) // → best = 5
```

### タプル型の 1 次元配列

この問題の解答を読むまで理解していなかったアプローチとして、辺を [number,number]の組で列挙して、それを配列で持っておくということ。2 次元配列にしないので、扱いがよりシンプルだった。コード上は下記の部分。

実際のデータの入っているとこまでイメージしやすい例としては下記のような感じ

```typescript
const allEdges: [number, number][] = [
  [0, 1], // タプル 1
  [0, 2], // タプル 2
  [1, 3] // タプル 3
]
```

412 d 問題での利用例

```typescript
const allEdges: [number, number][] = []
for (let i = 0; i < N; i++) {
  for (let j = i + 1; j < N; j++) allEdges.push([i, j])
}

///略
const [u, v] = allEdges[idx]
if (degree[u] < 2 && degree[v] < 2) {
  visited[idx] = true
  degree[u]++
  degree[v]++
  dfs(idx + 1, chosen + 1)
  degree[u]--
  degree[v]--
  visited[idx] = false
}
```

u,v は頂点の組。存在しうる辺のパターンの内容を表している。
タプル型で配列を作っておくことで、すべての辺の内容を列挙する際に、 idx を 0 からカウントアップしていくだけで、
すべての辺の種類にアクセスできる。

### 辺を N 個選べば、その時点でグラフ上の次数は N になる（ようにしている）

この問題は、頂点の次数が 2 になるようにして閉路を形成するようにする。
辺が頂点と同じ数だけ選ばれたときに、閉路の評価を行う。

1 つの辺が選ばれると、必ず 2 つの頂点に接続する。
辺が N 選ばれているときには、頂点ごとの次数が２になることが保証される※。

※
当然、何の制約もなく、辺を選んでいくと、N 個の辺を選んでも、閉路が形成されないときはある。
辺を選択する際に、下記のように制約を用意している。

下記のように。

```typescript
// 今選択中の辺(idx)を選ぶ分岐（次数制約を満たすときのみ）
const [u, v] = allEdges[idx]
if (degree[u] < 2 && degree[v] < 2) {
  //次数の選択処理
}
```

### バックトラッキングの利用

下記の処理における

```typescript
// 今選択中の辺(idx)を選ぶ分岐（次数制約を満たすときのみ）
const [u, v] = allEdges[idx]
if (degree[u] < 2 && degree[v] < 2) {
  visited[idx] = true
  degree[u]++
  degree[v]++
  dfs(idx + 1, chosen + 1)
  degree[u]-- //バックトラッキング　あるdfsの探索が終わるときに、元に戻す
  degree[v]--
  visited[idx] = false
}
```

下記の部分が バックトラッキングとなる。

```typescript
degree[u]-- //バックトラッキング　ある dfs の探索が終わるときに、元に戻す
degree[v]--
visited[idx] = false
```

この DFS では、すべての探索が同じ degree 配列と visited 配列を共有しています。これが重要なポイント。

例えば、辺 1,2,3 があったとする。
DFS なので、辺 1 を選ばない、という選択をしたとき、辺 1 を選ばない前提でのパターンを試していく。
辺 1 を選ばない場合での辺をすべて試し終わったときに、元の分岐に戻る。
この時、元に戻す処理を行わないと、辺 1 を選ぶパターンを検証するときに、元の選択状況及び次数が影響してしまう。

そのため、 degree[u]--, degree[v]--, visited[idx] = false を指定することで、元の状態に戻す。

### dfs をしながら、複数パターンを試す方法

この、dfs をしながら複数パターンを試す方法について、思い至らなかったので、解法のコードをもとにメモをしておく。
まず、複数の点の中をつなぐ次数を 2 つすることを目指す問題において、
点と点の組で配列を作成し、単純なカウントアップで全ての辺の組にトライできるようにしていること。

index のカウントアップをする → 別の辺のパターンを検証するという仕掛けになっている。

次に、dfs のコード内に

//今の辺を選ばない
dfs(idx +1, chosen)

//今選択中の辺(idx)を選ぶ分岐（次数制約を満たすときのみ）

という分岐を直接書いてしまうこと。このシンプルな実装が思い至らなかった。dfs の関数内に、選ぶパターン、選ばないパターンを書いていいんだね。
