```ts
// 大きな数の乗算時のオーバーフローを防ぐ関数
// 数値を 100 万で区切って上位部分と下位部分に分け、分配法則で計算
const prod = (a: number, b: number, mod: number): number => {
const al = Math.floor(a / 1e6) // a の上位部分
const ar = a % 1e6 // a の下位部分
const bl = Math.floor(b / 1e6) // b の上位部分
const br = b % 1e6 // b の下位部分
let p = 0
p += ar _ br // 下位同士
p += (al _ br + ar _ bl) _ 1e6 // 上位と下位の組み合わせ
p += al _ bl _ (1e12 % mod) // 上位同士
return p % mod
}
```

この関数が何をやっているか。

JavaScript の数値は 15 桁まで扱えないため、大きな数値は分割して計算しようとしている

数 a と数 b をそれぞれ 100 万で区切って「上位部分」と「下位部分」に分けます。
例えば、123456789 という数は、123(上位)と 456789（下位）に分けます。

掛け算の分配法則（al*10^6 + ar） * (bl\* 10^6 + br)を展開すると、4 つの項が出てきます。

4 つの項
= al×10⁶×bl×10⁶ + al×10⁶×br + ar×bl×10⁶ + ar×br

それぞれの項は元の数より小さいので、安全に計算ができる。

```
// 例: 123456789 を分割
a = 123456789
al = 123 // 上位 (100 万以上の部分)
ar = 456789 // 下位 (100 万未満の部分)

// 元の数は: a = al × 1000000 + ar
```

この問題を解くために知っておくべき重要な法則
「ある積に対する数 x による mod の結果は、事前にその項ごとに数 x による mod で得られた数に置き換えても、結果は変わらない」

普通に計算：
23 + 45 = 68
68 % 10 = 8
途中で mod を取る：
23 % 10 = 3
45 % 10 = 5

合同式の性質を利用する。

加法の性質：
(a + b) mod m = ((a mod m) + (b mod m)) mod m
乗法の性質：
(a × b) mod m = ((a mod m) × (b mod m)) mod m
