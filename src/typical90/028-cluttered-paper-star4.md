長方形の重なりの面積が、なぜ二次元 imos 法で計算できるのか。

この問題で求めたいこと：

- 各座標（x,y）について、何個の長方形がその座標を含んでいるか
- k 個の長方形に含まれる座標が何個あるか(k=1,2....,N)

愚直解の問題点：座標（x,y）ごとにすべての長方形をチェック → 　 O(1000² \* N) = 最大 10 億回の計算

imos 法の考え方

1 次元 imos 法の復習：区間(L,R)に一様に+1 したい場合：

- A[L] +=1, A[R] -=1 と設定
- 累積和を採ると、[L, R)の範囲だけ+1 される

```
元の配列: [0, 0, 0, 0, 0]
区間[1,4)に+1 したい

差分配列: [0, +1, 0, 0, -1]
累積和後: [0, +1, +1, +1, 0] ← 区間[1,4)だけ+1！
```

二次元 imos 法への拡張
長方形領域への一様操作：重宝計

```
cnt[lx][ly] += 1 // 左上角
cnt[lx][ry] -= 1 // 右上角
cnt[rx][ly] -= 1 // 左下角
cnt[rx][ry] += 1 // 右下角

```

なぜこの 4 つの値なのか：二次元累積和は「左上から短形和」を表します。座標(i,j)の累積和は、(0,0)から(i,j)までの長方形内の値の総和です。

長方形[lx,rx) \* [ly,ry]の値をすべて+1 するには：

- (lx, ly)以降すべての座標で+1 される必要がある →cnt[lx][ly] +=1
- (lx, ry)以降では元に戻したい → cnt[lx][ry]-=1
- (lx,ly)以降では元に戻したい　 → cnt[rx][ly] -=1
- (rx, ry)以降では上の 2 つの-1 が重複するので+1 で調整 →cnt[rx][ry]+=1

具体例で理解する
3×3 のグリッドで長方形[1,3) × [1,3)（つまり座標(1,1), (1,2), (2,1), (2,2)）に+1 したい場合：

Step 1: 差分配列に設定

```
   0  1  2  3
0  0  0  0  0
1  0 +1  0 -1
2  0  0  0  0
3  0 -1  0 +1
```

Step 2: 横方向累積和

```
   0  1  2  3
0  0  0  0  0
1  0 +1 +1  0
2  0  0  0  0
3  0 -1 -1  0
```

Step 3: 縦方向累積和

```
   0  1  2  3
0  0  0  0  0
1  0 +1 +1  0
2  0 +1 +1  0
3  0  0  0  0
```

結果、座標(1,1),(1,2),(2,1),(2,2)だけが+1 されている！

この問題での適用豊富お。

二次元 imos 法のイメージメモ。

左上には+1,右上には-1,左下には-1、右下には+1 を入れて、左 →→ への累積和、
上から下への累積和をとっていく問題。

ここで、なぜこのようなマイナス値の設定をするのか、ということの覚え方のイメージについて。
-1 でせき止める、イメージをした。

左 → 右に流れる時に、上側には 1 が加算されていく。下側では-1 の段ができていく。
次に、上から下に累積をしていくときに、上側には+1 があるので、下に累積をしていくが、
下の-1 行で値が 0 に戻る。

この →↓ といった累積をしたときに、-1 で加算をせき止めて 0 に戻すことで、ほしい累積和を求めることができる。
