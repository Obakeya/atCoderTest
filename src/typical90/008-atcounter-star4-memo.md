解法のコンセプト

1. 状態の定義：「文字列の i 文字目まで見て、目標文字列の j 文字列目まで作れる方法の数」を状態として持つ
2. 選択肢の分岐：各文字について、「使う」か「使わない」かの 2 つの選択肢がある
3. 条件付き遷移：文字列の i 文字目が、作成しようとする文字列のつい g の文字列として期待する文字と一致する場合のみ「使う」選択肢が有効になる
4. 累積計算：書く状態で可能な方法数を累積する

5. 初期化フェーズ

```ts
const dp: number[][] = Array(N + 1)
  .fill(null)
  .map(() => Array(T.length + 1).fill(0))
dp[0][0] = 1
```

- `dp[i][j]` ... 文字列 S の i 文字目まで見て、「atocoder」の j 文字目まで完成させる方法の数
- `dp[0][0] = 1`... 何も選んでいない状態から開始

2. メインループの動作

```ts
for (let i = 0; i < N; i++) {
  for (let j = 0; j <= T.length; j++) {
    // パターン1: S[i]を使わない
    dp[i + 1][j] = add(dp[i + 1][j], dp[i][j])
    //パターン2: S[i]を使う（条件付き）
    if (j < T.length && S[i] === T[j]) {
      dp[i + 1][j + 1] == add(dp[i + 1][j + 1], dp[i][j])
    }
  }
}
```

各ステップでの判断：

- S[i]を使わない場合：進行状況は変わらず、方法数をそのまま次に引き継ぐ
- S[i]を使う場合：文字が一致すれば目標文字列の次の文字列の次の文字に進める

具体例での動作確認（"aattccooddeerr"で"atcoder"を作る場合）
文字列位置 0 から順に見ていくと：

- 位置 0'a':'a'と一致 →dp[1][1]に方法数を追加
- 位置 1 'a':使わないか、

#### 数の増え方について

最初の 1 でカウントしているのを累積していくことで、解を求める方法。

数値が増えるというときは、 文字列 S の i 文字目まで見て、 期待する文字列 T における j 位置での文字がちょうど見つかった時である。そのため、S[i]の文字を T[j]で採用できるのはそのタイミングしかないため、そのタイミングで累積を行なってよい

2 次元の図面で考えるとわかりやすいかも。

i は文字列、j は文字列でカウントする。

文字列の 1 文字ごとに、文字列'atcoder'におけるすべての文字列のパターンのどこで一致するかをカウントする。atcoder は 7 文字ある。

S 文字列の、1 文字ごとに、7 文字のすべての一致パターンを見る。

### 「取り出した文字を順番を変えずに結合してできた」

元ある文字の位置の順番も重要である。

最終的に、答えを出力するときは、dp における dp[N][t.length]である。もし、1 つも組として、ケースを満たすパターンがなかった場合は、数字が伝播せず、dp[N][t.length]は 0 をする。

例えば、 文字列 atcoder における r が与えられた文字列に存在しない場合に、r の位置するところ、つまり T.length の位置にあるところは、すべて 0 になる。

同じ文字を 2 度取り出すことはできない。

### 値の増え方についておさらいする

```ts
for (let i = 0; i < N; i++) {
  for (let j = 0; j <= T.length; j++) {
    // パターン1: S[i]を使わない
    dp[i + 1][j] = add(dp[i + 1][j], dp[i][j])
    //パターン2: S[i]を使う（条件付き）
    if (j < T.length && S[i] === T[j]) {
      dp[i + 1][j + 1] == add(dp[i + 1][j + 1], dp[i][j])
    }
  }
}
```

文字が発見されない場合は、下記となる。つまり、ただの累積処理。
i + 1 というのは、文字列の増加を表す。初期値はすべて　 0、累積処理のため、値は変わらない。

//下への値を累積していく
`add[i+1][j] += dp[i][j]`

一致する文字が発見された場合は
//右下へ値を累積していく。
dp[i+1][j+1] += dp[i][j]

値が増えていくメカニズムについて。

基本的には文字列を 1 文字ごとに値を累積していく。
このとき、文字が発見されなかったときは、下に累積をする。

文字が発見されたときは、右下に累積する。

1
1 のような状態で、累積が発生するとき、 2 として値が増えていく。

1
1 となる、というのはどういう状態か？

1
1 の状態で縦に累積が起きるのは、文字が発見されないパターンである。

では、1 が縦に並ぶ、っていうのはどういう状態か？
事前に、右下に累積が発生したときに起きる。

つまり、使う、という累積が発生した後に、その後に
使わないが発生したパターンで値が増えていく。
