# 競技プログラミング典型 90

- 001 Yokan Party（★4）:二分探索法と貪欲法
- 002 Encyclopedia of ParentTheses（★3）:バックトラッキング
- 003 Longes Circular Road（★4）：円の直径の計算、DFS、隣接リスト
- 004 Cross Sum（★2）：前処理、累積和
- 007 Cp Classes（★3）:二分法探索法（与えられた値以上の最小の位置を返す）
- 008 AtCouter（★4）:動的計画法
- 010 Score Sum Queries（★2）：累積和、座標同士での引き算
- 012 Red Painting（★4）: UnionFind,2 次元 →1 次元変換
- 014 We Used to Singa a Song Together（★3）:ソートして貪欲法
- 016 Mininum Coins（★3）：式変形によりループを減らしして全探索。余りが 0→ 有効な組という判定
- 018 Statue of Chokudai（★3）：三角関数（円運動の公式、アークタンジェント（逆正接関数）、ピタゴラスの定理）
- 020 Log Inequality（★3）：小数点を避けて計算する、BigInt を用いる
- 022 Cubic Cake（★2）：最大公約数 → ユーグリッドの互除法、BigInt
- 024 Select+/-One（★2）：偶奇性（パリティ）を考える
- 026 Independent Set on a Tree（★4）：木 → 二部 グラフかつ隣り合わない頂点 → 色塗りによるグループ分け。　隣り合わない N/2 個の頂点 → グループわけが必要。
- 027 Sign UP Requests（★2）：すでに扱ったデータかどうか、ハッシュを使って判定する
- 028 cluttered paper（★4）：領域加算は二次元いもす法。左 → 右、上 → 下への累積加算をする。累積和を-1 でストップする考え方
- 032 AtCoder Ekiden（★3）：順列生成、制約チェック、バックトラッキングの基本実装が行えるかどうか、全探索、隣接リスト
- 033 Not Too Bright（★2）：境界値用のロジックを用意する。
- 034 There are few types of elements（★4）:単調性を利用した尺とり法
- 038 Large LCM（★3）：オーバーフローを避けるために式変形して除算をする。最大公約数から最小公倍数を求める
- 042 Multiple of 9（★4）：DP を使って解く。数が 1 増えるごとの解がどう変化していくかに着目する
- 044 見かけ上の変化をメモする、モジュロによって循環を表現する。位置を取得するためのコーディングは...(x - 1 + shifts) % N
- 046 余りを求めて計算するべき値をパターン化兼圧縮。全探索せずに登場回数の積で実現可能な組を求める。
- 048 i will not drop out：貪欲法。問題ごとの部分点、満点ごとに 1 分あたりのスコアとして平準化し、一次元配列に入れてソートする。満点取るときは必ず部分点を取っている前提のため、満点を取るのときのスコアは満点-部分点で表現できることに気づくことがポイント
- 052 Dice Product （★3）：因数分解をして式変形することで、O(N)にできる。式を書いてみて、計算量を落とすように式変形できるかどうかに気づけるか
- 055 Select5(★2)：オーダー記法では係数を無視するが、その係数の値が十分に小さいとわかっていて、制約から、全探索として O(N^3)のアルゴリズムを設計しても、解けることに気づく。計算結果がオーバーフローしないように、積を求める前に、項を mod に置き換えて計算する（合同式の性質）
- 61 Deck(★2)：C++には、deque という、両端への要素追加が O(1)で実行できるデータ小周防がある。TypeScrit にはその用意はない。ただ、データ量が制約上少ないため、push()と unshift()で解ける。unshift()は、配列の全要素分の O(n)の時間がかかることにちゅい
- 67 Base 8 to 9(★2)：8 進数 →9 進数への変換をするには、8 進数 →10 進数 →9 進数という過程を経る。数字が大きいときは BigInt を扱い、BigInt は、N 進数を 10 進数変換する際に、指定の文字列リテラルを接頭辞につける

# AtCoder Beginer Contest

- 081
  - C Not So Diverse：記憶用の配列作成、インデックスの位置と数字の値を一致させてカウント、値が多い順にソート。許容数を超える分を slice して合計値を累積して出力
- 230
  - C X drawing: まず、問題文の書き方が競プロ的で難しい。「Q-P+1 行出力せよ」→ これは、P 行から Q 行までを出力せよ、という意味。「各行は # と . のみからなる長さ S−R+1 の文字列であり」→ これは、R 列から S 列までを出力せよ、という意味。制約の数値が大きいため、BigInt での比較用関数を作成した。黒く塗る位置が（A+k, B+k）または(A+k,B-k)であることから、問題文通り、斜めの線を書くように黒く塗る位置が決まることをイメージすべきだった。斜めの線ということは、ある座標 x の位置において、黒く塗れるのは、濡れない、もしくは 1 か所塗れるということである。それを満たすように黒色かどうかの判定をすべきところを、私は長方形領域で判断してしまった。ある k の値を決定すると、それと同時に i と j の値は決まるのである。一方、私は逆で、先に取りうる値が可能な i と j の組の範囲を考える、というアプローチに至ってしまった。
- 249
  - C Just K :全探索かつビット演算で求める。制約が小さく、「ありうる最大値」を求めること全探索と気づきたい。「好きなように選ぶ」ため、選ぶ組は 2^N で決まる。選ぶ順序は関係ないため、N!とならないことに注意。選ぶ・選ばないが大切な時は、ビット演算で組を表現できないか留意しよう。
- 254
  - C K Swap：K 個離れた要素同士しか交換できないことから、0~K までの mod の数値グループに、数値を分ける。それぞれのグループから昇順に値を取り出して配列を作っていき、正解の配列と値が一致しているかを比較。O(N log N)で解くことができる。
- 278
  - D:All Assign Point Add
    - 特定の位置への加算処理と、配列全ての置き換え処理が発生する。置き換え処理が発生するすると、それまでの加算処理は無かったことになるため、それをどうコード上簡潔に表現するかがポイント。位置ごとの加算処理を配列を使って行っている場合、配列全体を初期化するために O(N)の処理が必要となる。Map を使って管理することで、 Map.clear()で値のリセットをシンプルに管理できる。
- 286
  - C : Rotate and Palindrome:　制約が ≤5000 で、最低コストを求めることから、全探索を用いると導く。文のローテーションの結果をシュミレーションするために、与えられた文字列を 2 つ結合し、ローテーション回数分開始位置をずらすことで、ローテーション結果を判断できる。ローテーション回数ごとのコストを求め、最終的な最低コストを算出する
- 293
  - C - Make Takahashi Happy：後戻り方向のない移動なので DFS ではなく、バックトラッキング。二次元座標での x,y の取り違え注意
- 300
  - C - Cross:データ量が少ないため、問題の制約通りの実装で正答できる。サンプルコードとしては、マスを全探索しながら、× 形状を満たすかどうか、現在位置から 4 済みに対してチェックをする。× かどうかを判定するためのシンプルな関数を作るなどのコツ
- 335
  - D - Loong and Takahashi:螺旋状パターン生成、左上から始める、進行方向を dx,dy の組で表現する、今の進行方向を index とし、その index で進行方向用の値を採る
- 343
  - D - Diversity of Scores：全選手分の点数をメモするための配列を作成。全体のユニーク数を記録するための Set、それぞれのスコアが今何件あるかを Map で管理する
- 382
  - C Kaiten Sushi：答え用の辞書を作っておく。1 から max 値の美食度において、どの人に食べられることになるかを事前計算する。その後、寿司ごとの美食度から食べられひとを参照して答えにする
- 420
  - C - Sum of Min QUery：事前の和計算と差分計算
  - D - Toogle Maze：3 次元 BFS[状態,x,y]、2 次元グリッドでの A→B の最短距離を求める
- 421
  - C Alternated（交互の）：出現順序と目標位置のマッピング（A は A 同士の比較において相対的位置は変わらない）→A の位置のみに注目し、理想位置との現在位置の理想距離の累積和で考える（前の処理で A の位置がずれることは、相対的な位置が変わらない以上、六）
- 423
  - C Lock All Doors：移動に伴うコスト計算。両端を最初に決定し、閉じているドア、開いているドアに基づきコスト計算する。左から移動しても右から移動しても計算距離は変わらない
- 424
  - C New Skill Acquired:連結リスト（有向グラフ）を作る。あるスキルから到達可能なスキルについて、dfs を使って、習得可能なスキルまで到達できるかを考える
  - D 2*2 Erasing 2:ビットマスク DP で解く。行ごとの状態をビットで表現し、すべての行と行の組をビットで表現し、黒 2*2 となる組を判定する。パターン自体がビットで表現されるため、パターンを表現するビットの組自体が index になる。ある組とある組を比較する際に xOR を求めることで、コストを計算でき
- 427
  - C Bipartize:辺を管理する場合は、多次元配列ではなく、タプルのほうが便利。ある頂点を塗る or 塗らないについて、ビット全探索で行う、というアプローチはあっていた。連結リストから値を取り出すため、無駄に複雑な実装になっていた。
