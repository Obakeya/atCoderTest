## 浮動小数点数とは

浮動小数点数は、コンピューターが限られたメモリで実数を**近似的に**表現する仕組みです。科学記数法（1.23×10^4）のように、符号・指数・仮数の 3 つの部分で数値を構成し、非常に大きな数から小さな数まで幅広く扱えます。

ただし、コンピューターは内部で 2 進数を使うため、10 進数の 0.1 や 0.3 などは正確に表現できず、微小な誤差が発生します。この誤差により、`0.1 + 0.2 === 0.3`が`false`になるような現象が起きます。

つまり浮動小数点数は「便利だが完璧ではない実数の近似表現」であり、金融計算など精度が重要な場面では整数ベースの計算や専用ライブラリの使用が推奨されます。

### 仮数部と指数部とは？

仮数部は「数字そのもの」、指数部は「その数字をどの桁に置くかを示す倍率」です。

たとえば 1.23 × 10⁴ を考えると、1.23 が仮数部、4 が指数部です。
コンピューターではこれを 2 進数で保存するので「仮数部 1.xxxxx₂ と指数部 e」の形になります。仮数部に細かい桁を詰め込み、指数部が「2 を何回掛けるか」でスケールを調整する——この二段構えで、巨大な数から極小の数まで同じフォーマットで扱えるわけですね

### なぜ、2 を何回かけるのか、という持ち方になるのか

コンピューターの内部はすべて 2 進数で動いています。2 進数で動いています。2 進数では 1 桁シフト 1 桁シフトするだけで「×2」や「÷2」が機械的に行えます。つまり、

- 仮数部ーー細かい数字ーーはそのまま保持し、
- どの桁に置くかだけを「2 を何回掛けるか」という指数部で示す
  という形にすると、ハードウェアは

1. 仮数部をそのまま読みだす
2. 指数部の値だけビットをずらす（シフト演算）という単純な手順で実数を復元できます。
   もし、10 を基準にした指数を使うと、毎回「×10^n」の変換をしなければならず、回路が複雑かつ遅くなります。2 の累乗を採るのは"シフト"という最も原始的で高速な操作でスケール調整が完結するから、というわけです。

#### スケール調整

スケール調整とは、「数そのものは変えずに、桁位置を動かして扱いやすい大きさに整える」ことです。

浮動小数点数ではまず仮数部を 1.xxxx...という標準形に揃えます。すると、元の値が 1 兆でも 0.00001 でも仮数部は常に 1 と少しの小数という手ごろな範囲に収まります。あとは指数部で「2 を何回掛ける（または割る）か」を指定すれば、最終的な桁位置ーーつまりスケールを元に戻せます。

### 正規化

IEEE‑754 では仮数部を必ず 1.xxxxx…（2 進なら 1.\*\*\*\*\*₂）に整形します。この「1」は保存せずとも常に 1 と分かるため **隠れビット(implicit 1)** と呼ばれ、実際の記憶域は 52 bit + 1 bit = 53 bit となります。

---

##　桁数が大きい数字の計算方法

桁数が大きい数字の計算方法  
JavaScript の number 型は、15 桁（正確には 15-17 桁）を超える整数で精度が失われるという重要な制約があります。これは Number.MAX_SAFE_INTEGER（2^53 - 1 = 9,007,199,254,740,991）を超える数値で発生し、競技プログラミングや金融システムでは致命的な問題となります。

代わりに`BigInt`を利用しましょう。
