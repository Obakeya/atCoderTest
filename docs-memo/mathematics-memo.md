### 合同式とは

合同式は、18 世紀の数学者ガウスによって導入された概念で、「異なる整数を、ある数で割った余りによってグループ分けする」という考え方。合同式は、周期的な現象を

#### 合同式の定義

整数 a、b、n に対して、 a ≡ b(mod n)と書いて「a は b と n を法として合同である」と読みます。
これは、以下の 2 つの条件のいずれかが成り立つことを意味します。

13 % 12 = 1

1. a と b を n で割った余りが等しい
2. a-b が n の倍数である

   つまり、 a ≡ b(mod n)⇔ a - b =kn(k は整数)

具体例で考える。例えば、 13 時と 1 時は合同である。

実際に確認すると、
13÷12=1 余り 1
1÷12=0 余り 1
これらは、余りが同じなので合同である、と言える。

合同式の定義に当てはめると、

13 ≡ 1(mod 12) とかく。

### mod 演算と合同式の関係

a mod n = b ⇔ a = b (mod n)
上記のように、式を変形できる。
左辺は
a を n で割った余りが b という意味となり、
右辺は a と b は n で割った余りが同じ、という意味になる

例
13 mod 10 = 3 となる　
ここで、　
合同式の関係より
13 = 3 ( mod 10)

a mod b = 演算（計算）
「a を b で割った余り」という具体的な値を求める
c (mod d) = 条件・関係
「d で割った余りが同じ」という関係性を表す

### べき乗とは

べき乗とは、同じ数を自信になんども掛ける計算方法のこと

### 累積和

左から順番に足していった結果を、全部覚えておくこと。

累積和は、1 つの数字ではなく、配列全体のことを指します。

```
元の配列: [100, 200, 50, 300]
累積和配列: [100, 300, 350, 650]
↑ ↑ ↑ ↑
全部が累積和の一部
```

それぞれの意味

100: 1 日目までの累計
300: 2 日目までの累計
350: 3 日目までの累計
650: 4 日目までの累計

どの位置の累計も「累積和」と呼びます。

#### 全ての組み合わせの積の和を高速化する

「i < j なる全ての組について A_i × A_j の和」を求める問題で使用する。
愚直に二重ループで計算すると O(N²) だが、累積和を使うと O(N) で解ける。

**発想の転換がポイント**

愚直解の視点: A_1×A_2 + A_1×A_3 + A_1×A_4 + A_2×A_3 + A_2×A_4 + A_3×A_4

累積和の視点: 各要素から見て「その要素 × 前の要素の合計」
A_2 × (A_1) + A_3 × (A_1+A_2) + A_4 × (A_1+A_2+A_3)

**実装パターン**

```typescript
let answer = 0n
let sum = 0n // 累積和

for (let i = 0; i < nums.length; i++) {
  answer += sum * BigInt(nums[i]) // 現在の要素 × これまでの累積和
  sum += BigInt(nums[i]) // 次のループのために累積和を更新
}
```

**計算例：[1, 2, 3, 4]**

```
i=0: answer += 0 × 1 = 0, sum = 1
i=1: answer += 1 × 2 = 2, sum = 3
i=2: answer += 3 × 3 = 9, sum = 6
i=3: answer += 6 × 4 = 24, sum = 10
結果: 2 + 9 + 24 = 35
```

注意：答えが大きくなる場合は BigInt を使用する。

### 添字とは

添字（そえじ）とは、配列の各要素の**位置を表す番号**のことです。
インデックスとも呼ばれます。

**例：**
配列 [1, 3, 5, 7, 9] があるとき：

- 添字 0：値 1
- 添字 1：値 3
- 添字 2：値 5
- 添字 3：値 7
- 添字 4：値 9

プログラミングでは通常、添字は 0 から始まります。

### 4 近傍とは

「4 近傍（よんきんぼう）」は格子状のグリッドで、あるマスの上下左右に接する 4 つのマスの酒豪を指します。対角方向（斜め）は含めません。

対照的に、上下左右+斜め 4 方向を加えた 8 つの隣接マスは「8 近傍（はちきんぼう）」と呼びます。

### |A|という書き方について

|A| は配列（列）A の要素数、つまり、A に含まれている値の個数を表します。
英語では、length of A や、size A と呼ばれるもの。

### |r|という書き方について

ここでは、r の絶対値を表現する

### ≤ と ≦ について

意味はどちらも以下。違うのは見た目だけ。

### 幾何平均とは

- **定義**
  $n$ 個の正の数 $x_1,\dots,x_n$ の掛け算を取り、その $n$ 乗根を取った値。

  $$
    \mathrm{GM}(x_1,\dots,x_n)=\bigl(x_1x_2\cdots x_n\bigr)^{1/n}
  $$

- **本質**

  - 「差」ではなく「倍率（比率）」を平均したいときの指標。
  - 等比数列の真ん中要素が両断の幾何平均になる（$b^2=ac$）。

- **用途例**

  - 福利の年平均利回り
  - 成長率・減衰率の平均
  - 濃度希釈やスケールの均一化

- **性質**

  - **AM ≥ GM ≥ HM**（算術平均 ≥ 幾何平均 ≥ 調和平均）。
  - 全要素が等しいとき、算術平均と一致

- **注意点**

  - 負の数が含まれると実数範囲では定義不可（0 があると結果は 0）。

### 俯角とは

俯角とは、水平線から下向きに測った角度のこと。
└ まっすぐ前を向いた状態から下を向く角度

```
     観測点
        ●
        |\
        | \
水平線--|   \ 俯角 θ
        |   \
        |    \
        |     ●
          対象物

```

よくある問題パターン

1. 座標問題：高い点から低い点を見る角度
2. 三角関数:tan(俯角) = 高さの差 / 水平距離
3. 幾何問題：視線と水平線の角度計算

## 三角関数について

三角形の辺の比の関係について、分析する。

```
  |＼
a |  ＼ c (斜辺)
  |    ＼
  |θ_____＼
     b
```

sin：高さの割合を示す...斜辺に対して、どれぐらい高いか → 立てかけた梯子の長さから、高さを求められる
cos：幅の割合を示す...斜辺に対して、どれぐらい横にあるか → 立てかけた梯子の長さから、水平での幅が分かる

- sinΘ = 対辺 ÷ 斜辺 = a ÷ c
- cosΘ = 隣辺 ÷ 斜辺 = b ÷ c

### ラジアンによって角度を表す方法について

度数法 vs ラジアン

普段使う「度数法」とは

- 一周 = 360°、 半周 = 180° 、直角 = 90°

数学で使う「ラジアン」とは

- 一周 = 2π ラジアン 半周 = π ラジアン　直角 = π/2 ラジアン

JavaScript の三角関数はすべてラジアンで計算する。
180° という表現を計算から排除でき、計算過程がシンプルになる。

```js
// 時刻 I での角度（ラジアン）
const angle = (I / T) * 2.0 * PI

// これは以下と同じ意味：
// T 分で一周（360 度 = 2π ラジアン）
// I 分経過 → 全体の I/T 進んだ
// 角度 = 2π × I/T
```

### 円運動の公式

公式の内容
x = r × cos(θ)
y = r × sin(θ)

```ts
//018-statue-of-chokudaiでの利用例
// Lは直径
const cy = -(L / 2.0) * Math.sin((I / T) * 2.0 * PI)
const cz = L / 2.0 - (L / 2.0) * Math.cos((I / T) * 2.0 * PI)
```

- 観覧車が円運動するときの座標を計算
- `I/T * 2.0 * PI` = 現在の角度（ラジアン）
- 半径 `L/2`の円上での位置を求める

### 逆正接関数（arctangent）アークタンジェント

θ = atan2(y, x)

コードでの使用法

```ts
const kaku = Math.atan2(d2, d1)
```

何をしているか：

- 水平距離 d1 と、高さ差 d2 から角度を計算する
- 俯角（見下ろす角度）を求める
- Math.atan()もあるが、こちらだと　象限の情報が失われるため、　 atan2 を利用する

### ピタゴラスの定理

斜辺 ² = 横の距離 ² + 縦の距離 ²
斜辺 = √(横の距離 ² + 縦の距離 ²)

```ts
//018-statue-of-chokudaiでの利用例
//このとき、観覧車の位置： (cx, cy)　銅像の位置： (X, Y)より、
//横の距離 = cx - X、縦の距離 = cy - Y
const d1 = Math.sqrt((cx - X) ** 2 + (cy - Y) ** 2)
```

### ユーグリッドの互除法

ユーグリッドの互除法は、2 つの整数の最大公約数(CGD:Greatest Common Division)を効率的に求めるアルゴリズム。

核心となる性質：gcd(a,b) = gcd(b, a %b)

この性質により、大きな数を小さな数で割った余りを使って、問題を段階的に小さくしていくことができる。
余りが 0 になったとき、その除数が最大公約数となります。

除数...割り算で割る数のこと。

被除数：割られる数
除数：割る数
商：割り算の結果

```ts
function gcd(a: number, b: number): number {
  while (b !== 0) {
    ;[a, b] = [b, a % b] //同時代入でスワップ
  }
  return a
}

console.log(gcd(48, 18))
console.log(gcd(100, 75))

///あるいは、下記のようにも掛ける
function gcd(a: bigint, b: bigint): bigint {
  if (b === 0n) return a
  return gcd(b, a % b) // A を gcdで割った数
}
```

最大公約数を求める関数を応用すると、最小公倍数を求めることもできる。  
最小公倍数...lcm(Leatest Common Multiple)

関係性

```ts
lcm(A,B) = (A * B) / gcd( A,B)
lcm(A,B) * gcd(A,B) = A * B
```

A と B の最小公倍数は、A と B の積を A と B の最大公約数で割った数に等しい。
A と B の最大公約数の積と A と B の最小公倍数の積は、A と B の積に等しい。

### 区間記法

`[)`は**区間記法**（または**集合記法**）で、数学やプログラミングでよく使われる表記です。

**記号の意味**：

- `[` ： その値を**含む**（閉区間）
- `]` ： その値を**含む**（閉区間）
- `(` ： その値を**含まない**（開区間）
- `)` ： その値を**含まない**（開区間）

## 具体例

**`[1, 4)`の場合**：

- `1` を含む（`[`だから）
- `4` を含まない（`)`だから）
- つまり「1 以上 4 未満」= {1, 2, 3}

**他の例**：

- `[1, 4]` → 1 以上 4 以下 = {1, 2
- , 3, 4}
- `(1, 4)` → 1 より大きく 4 未満 = {2, 3}
- `(1, 4]` → 1 より大きく 4 以下 = {2, 3, 4}

`[lx, rx) × [ly, ry)`

- x 座標：lx 以上 rx 未満の範囲
- y 座標：ly 以上 ry 未満の範囲　ということを意味する。
